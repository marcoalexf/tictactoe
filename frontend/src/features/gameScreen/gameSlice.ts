import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit';
import { RootState, AppThunk } from '../../app/store';
import { IPlayerMove } from '../../models/IPlayerMove.interface';
import { fetchCount } from './gameApi';

export interface GameState {
  gameBoard: string[];
  gameOver: boolean;
  winner: string | undefined;
  currentPlayer: 'X' | 'O';
}

const initialState: GameState = {
  gameBoard: ['', '', '', '', '', '', '', '', ''],
  gameOver: false,
  winner: undefined,
  currentPlayer: 'X',
};

export const updateGameStateAsync = createAsyncThunk(
  'counter/updateGameState',
  async (amount: number) => {
    const response = await fetchCount(amount);
    // The value we return becomes the `fulfilled` action payload
    return response.data;
  }
);

export const gameSlice = createSlice({
  name: 'game',
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    makeMove: (state, action: PayloadAction<IPlayerMove>) => {
      if (state.gameBoard[action.payload.move] === '') {
        state.gameBoard[action.payload.move] = state.currentPlayer;
        state.currentPlayer = state.currentPlayer === 'X' ? 'O' : 'X';
      }
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(updateGameStateAsync.fulfilled, (state, action) => {
      });
  },
});

export const { makeMove } = gameSlice.actions;

export const selectCurrentPlayer = (state: RootState) => state.game.currentPlayer;
export const selectCurrentGameBoard = (state: RootState) => state.game.gameBoard;
export const selectIsGameOver = (state: RootState) => state.game.gameOver === true;
export const selectWinner = (state: RootState) => state.game.winner;

export default gameSlice.reducer;
